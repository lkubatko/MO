---
title: "Simulation Study"
author: "Yuan Gao, Jeff Gaither, Julia Chifman ,and Laura Kuatko"
#date: "10/2/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This document contains code to reproduce the simulations in the manuscript "A Phylogenetic Approach to Inferring the Order in Which Mutations Arise during Cancer Progression" by Yuan Gao, Jeff Gaither, Julia Chifman, and Laura Kubatko.<br><br>

We set the initial seed here, so that the results presented in the manuscript can be reproduced exactly. If you would like to repeat the simulation study with a different set of randomly generated data, you need only change the seed in the chunk below.

```{r}
set.seed(1000)
```

#### Part I: Figures3_4_Scenario1 ####

We include here the following functions in the script:
<ul>
<li> <b>MO_binary</b> -- computes the probability of mutations on branches with binary data
<li> <b>MO_ternary</b> -- computes the probability of mutations on branches with ternary data
<li> <b>compare_all_order</b> -- computes the order accuracy
<li> <b>compare_near_order</b> -- computes the adjacent order accuracy
</ul>

To get started, we demonstrate how the functions work. We can compute the probabilities of mutations on branches for trees with $\alpha$, $\beta$, $\lambda_1 = 10^{-7}$, and $\lambda_2 = 10 ^{-2}$ for binary data as follows:

```{r}
  
sessionInfo()

#load functions for binary data
##############################################################################
source("./Figures3_4_Scenarios1_2/Scenario1_result/code_MO_binary_function.R")

sessionInfo()

parameter_setting = expand.grid(alpha=c(0.05,0.1,0.2,0.4),
                                beta =c(0.05,0.1,0.2,0.4))
set.seed(1000)
 
#get the parameters in each setting, binary complete
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  
  unit_theta = 10^(-7) #lambda_1 rate from 0 to 1
  unit_gamma = 10^(-9) #rate from 0 to 2
  
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
#return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }

  #create folder to store output
  binary_folder_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/Binary_alpha0%s_beta0%s_result',alpha_str, beta_str)
  dir.create(binary_folder_form)
  
  #in each setting, there are 100 trees, iteratively to estimate mutation order based on each tree
  for (indexn in 1:100){
    
    print(c(parameterIndex,indexn))
    
    #Tree_form is the tree file name. Scan and read the tree file into R 
    Tree_form=sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
    sampletr = read.tree(Tree_form)
    
    #read the simulated data into R
    obs_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New/Binary_alpha0%s_beta0%s/binary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
    mat_obs_form_0_1 = read.csv(obs_form)
    
    #recode the normal,mutation, and observed data for inference
    initial_obs_0_1 = data.frame(mat_obs_form_0_1[,-c(1,2,3)])
    initial_obs_0_1_recode = initial_obs_0_1 
    initial_obs_0_1_recode[initial_obs_0_1_recode >1] <- 1 #convert ternary to binary
    initial_obs_0_1_recode[initial_obs_0_1_recode == "-"] <- 3 #recode missing values to 3
    
    #initialize vector to store estimated probability and MAP estimates for iteration indexn
    binary_prob_matrix_all_0_1=c()
    selected_br=c()
    
    

    for (i in 1:dim(initial_obs_0_1_recode)[1]){
      
      
      #compute probability that mutation i on each of the branches on the tree
      #random sample mutation rates
      rd_unit_theta =  rgamma(n = 3, shape = 100, scale = 0.01*unit_theta)
      rd_unit_gamma = rgamma(n = 3, shape = 100, scale = 0.01*unit_gamma)
      
      generate_prob_br_all_dat=data.frame(matrix(NA, nrow = number_br, ncol = 3))
    
      for (j in 1:3){
      
      generate_prob_br <- MO_binary(alpha,beta,rd_unit_theta[j]+rd_unit_gamma[j],initial_obs_0_1_recode[i,],sampletr)
      generate_prob_br_all_single <- c(generate_prob_br,rep(0,number_br-length(generate_prob_br)))
      generate_prob_br_all_dat[,j] = generate_prob_br_all_single}
    
      probs=rowMeans(generate_prob_br_all_dat, na.rm = FALSE, dims = 1)

      #find the MAP estimate
      selected_br[i]=which.max(probs)
      
      #save the ith result to the matrix
      binary_prob_matrix_all_0_1 = rbind(binary_prob_matrix_all_0_1,probs)
      
    }
      
    # combine the true mutation branch on column 1 and the inferred mutation branch on column 3 for future comparison
    binary_prob_matrix_all_0_1_rownames=cbind(mat_obs_form_0_1[,c(2,3)],selected_br,binary_prob_matrix_all_0_1)
    
    # save inferred result for future comparison
    binary_prob_matrix_all_0_1_out = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
    write.csv(binary_prob_matrix_all_0_1_rownames,file=binary_prob_matrix_all_0_1_out)
    
  }
}


##############################################################################
#binary 10 missing
set.seed(2000)
#get the parameters in each setting
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  unit_theta = 10^(-7) #rate from 0 to 1
  unit_gamma = 10^(-9) #rate from 0 to 2
  
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  binary_folder_form = sprintf('/fs/project/kubatko.2-temp/gao.957/workspace/github_MO/Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/Binary_alpha0%s_beta0%s_result',alpha_str, beta_str)
  
  dir.create(binary_folder_form)
  
  #in each setting, there are 100 trees, iteratively to estimate mutation order based on each tree
  for (indexn in 1:100){
    
    print(c(parameterIndex,indexn))
    
    # Tree_form is the tree file name. Scan and read the tree file into R
    Tree_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
    sampletr = read.tree(Tree_form)
    
    #read the simulated data into R
    obs_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_10Missing/Binary_alpha0%s_beta0%s/binary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
    mat_obs_form_0_1 = read.csv(obs_form)
    
    #recode the normal,mutation, and observed data for inference
    initial_obs_0_1 = data.frame(mat_obs_form_0_1[,-c(1,2,3)])
    initial_obs_0_1_recode = data.frame(matrix(,nrow=dim(initial_obs_0_1)[1],
                                               ncol=dim(initial_obs_0_1)[2]))
    
    
    for(rownum in 1:dim(initial_obs_0_1)[1]){
      for(colnum in 1:dim(initial_obs_0_1)[2])
        
        if(initial_obs_0_1[rownum,colnum] == "-"){
          
          initial_obs_0_1_recode[rownum,colnum] = 3 #recode missing values to 3
          
          
        }else if(initial_obs_0_1[rownum,colnum] == "0"){
          initial_obs_0_1_recode[rownum,colnum] = 0
        }else if(initial_obs_0_1[rownum,colnum] == "1"){
          initial_obs_0_1_recode[rownum,colnum] = 1
        }else{
          print("value does not exist")
        }
    }
    
    colnames(initial_obs_0_1_recode) = colnames(initial_obs_0_1)
    #initialize vector to store estimated probability and MAP estimates
    binary_prob_matrix_all_0_1=c()
    selected_br=c()
    
    
    for (i in 1:dim(initial_obs_0_1_recode)[1]){
      
      #compute probability that mutation i on each of the branches on the tree
      
      rd_unit_theta =  rgamma(n = 3, shape = 100, scale = 0.01*unit_theta)
      rd_unit_gamma = rgamma(n = 3, shape = 100, scale = 0.01*unit_gamma)
      
      generate_prob_br_all_dat=data.frame(matrix(NA, nrow = number_br, ncol = 3))
      
      for (j in 1:3){

        generate_prob_br <- MO_binary(alpha,beta,rd_unit_theta[j]+rd_unit_gamma[j],initial_obs_0_1_recode[i,],sampletr)
        generate_prob_br_all_single <- c(generate_prob_br,rep(0,number_br-length(generate_prob_br)))
        generate_prob_br_all_dat[,j] = generate_prob_br_all_single
        
      }

      probs = rowMeans(generate_prob_br_all_dat, na.rm = FALSE, dims = 1)
      
      #find the MAP
      selected_br[i] = which.max(probs)
      #save the ith result to the matrix
      binary_prob_matrix_all_0_1 = rbind(binary_prob_matrix_all_0_1,probs)
      
    }

    # combine the true mutation branch on column1 and the inferred mutation branch on column 3 for future comparison
    binary_prob_matrix_all_0_1_rownames=cbind(mat_obs_form_0_1[,c(2,3)],selected_br,binary_prob_matrix_all_0_1)
    # save inferred result for future comparison
    binary_prob_matrix_all_0_1_out = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
    write.csv(binary_prob_matrix_all_0_1_rownames,file=binary_prob_matrix_all_0_1_out)
    
  }
}



##############################################################################
#binary 20 missing
set.seed(3000)
#get the parameters in each setting
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  unit_theta = 10^(-7) #rate from 0 to 1
  unit_gamma = 10^(-9) #rate from 0 to 2
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  binary_folder_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/Binary_alpha0%s_beta0%s_result',alpha_str, beta_str)
  dir.create(binary_folder_form)
  
  #in each setting, there are 100 trees, iteratively to estimate mutation order based on each tree
  for (indexn in 1:100){
    
    print(c(parameterIndex,indexn))
    
    # Tree_form is the tree file name
    Tree_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
    
    #scan and read the tree file into R 
    sampletr = read.tree(Tree_form)
    
    #read the simulated data into R
    obs_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_20Missing/Binary_alpha0%s_beta0%s/binary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
    mat_obs_form_0_1 = read.csv(obs_form)
    
    #generate the normal,mutation, and observed data for inference
    normal_genotype_0_1 = rep(0,dim(mat_obs_form_0_1)[1])
    mutation_genotype_0_1 = rep(1,dim(mat_obs_form_0_1)[1])
    initial_obs_0_1 = data.frame(mat_obs_form_0_1[,-c(1,2,3)])
    #recode data
    initial_obs_0_1_recode = data.frame(matrix(,nrow=dim(initial_obs_0_1)[1],
                                               ncol=dim(initial_obs_0_1)[2]))
    
    
    for(rownum in 1:dim(initial_obs_0_1)[1]){
      for(colnum in 1:dim(initial_obs_0_1)[2])
        
        if(initial_obs_0_1[rownum,colnum] == "-"){
          
          initial_obs_0_1_recode[rownum,colnum] = 3 #recode missing values to 3
          
          
        }else if(initial_obs_0_1[rownum,colnum] == "0"){
          initial_obs_0_1_recode[rownum,colnum] = 0
        }else if(initial_obs_0_1[rownum,colnum] == "1"){
          initial_obs_0_1_recode[rownum,colnum] = 1
        }else{
          print("value does not exist")
        }
    }
    
    colnames(initial_obs_0_1_recode) = colnames(initial_obs_0_1)
    #initialize vector to store estimated probability
    binary_prob_matrix_all_0_1=c()
    #initialize vector to store MAP estimates
    selected_br=c()
    
    
    for (i in 1:dim(initial_obs_0_1_recode)[1]){
      
      #print(i)
      #compute probability that mutation i on each of the branches on the tree
      #probs <- MO_binary(alpha,beta,unit_theta+unit_gamma,initial_obs_0_1_recode[i,],sampletr)
      rd_unit_theta =  rgamma(n = 3, shape = 100, scale = 0.01*unit_theta)
      rd_unit_gamma = rgamma(n = 3, shape = 100, scale = 0.01*unit_gamma)
      
      generate_prob_br_all_dat=data.frame(matrix(NA, nrow = number_br, ncol = 3))
      
      for (j in 1:3){
        
        
        
        generate_prob_br <- MO_binary(alpha,beta,rd_unit_theta[j]+rd_unit_gamma[j],initial_obs_0_1_recode[i,],sampletr)
        
        
        generate_prob_br_all_single <- c(generate_prob_br,rep(0,number_br-length(generate_prob_br)))
        
        
        generate_prob_br_all_dat[,j] = generate_prob_br_all_single
        
      }
      
      
      probs = rowMeans(generate_prob_br_all_dat, na.rm = FALSE, dims = 1)
      
      #find the MAP
      selected_br[i] = which.max(probs)
      
      #save the ith result to the matrix
      binary_prob_matrix_all_0_1 = rbind(binary_prob_matrix_all_0_1,probs)
      
    }
    
    
    
    binary_prob_matrix_all_0_1_out = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
    
    
    # combine the true mutation branch on column1 and the inferred mutation branch on column 3 for future comparison
    binary_prob_matrix_all_0_1_rownames=cbind(mat_obs_form_0_1[,c(2,3)],selected_br,binary_prob_matrix_all_0_1)
    # save inferred result for future comparison
    write.csv(binary_prob_matrix_all_0_1_rownames,file=binary_prob_matrix_all_0_1_out)
    
    
  }
  
}
  
  
```

Next, we compute the probabilities of mutations on branches for trees with $\alpha$, $\beta$, $\lambda_1 = 10^{-7}$, and $\lambda_2 = 10 ^{-2}$ for ternary data as follows:

```{r}
#load functions for ternary data
##############################################################################
source("./Figures3_4_Scenarios1_2/Scenario1_result/code_MO_ternary_function.R")

sessionInfo()

parameter_setting = expand.grid(alpha=c(0.05,0.1,0.2,0.4),
                                beta =c(0.05,0.1,0.2,0.4))
set.seed(10000)
#iteratively to run data in each setting
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  unit_theta = 10^(-7) #rate from 0 to 1
  unit_gamma = 10^(-9) #rate from 0 to 2
  unit_mu = 10 ^(-2) #rate from 1 to 2
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  ternary_folder_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/Ternary_alpha0%s_beta0%s_result',alpha_str, beta_str)
  dir.create(ternary_folder_form)
  
  #in each setting, there are 100 trees, iteratively to estimate mutation order based on each tree
  for (indexn in 1:100){
    
    print(c(parameterIndex,indexn))
    
    #Tree_form is the tree file name. Scan and read the tree file into R
    Tree_form=sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
    sampletr = read.tree(Tree_form)
    
    #read the simulated data into R
    obs_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New/Ternary_alpha0%s_beta0%s/ternary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
    mat_obs_form_0_1 = read.csv(obs_form)
    
    #recode the normal,mutation, and observed data for inference
    initial_obs_0_1 = data.frame(mat_obs_form_0_1[,-c(1,2,3)])
    initial_obs_0_1_recode = initial_obs_0_1 
    
    #initialize vector to store estimated probability.Initialize vector to store MAP estimates
    ternary_prob_matrix_all_0_1=c()
    selected_br=c()
    
    for (i in 1:dim(initial_obs_0_1_recode)[1]){
      
      #compute probability that mutation i on each of the branches on the tree
      rd_unit_theta =  rgamma(n = 3, shape = 100, scale = 0.01*unit_theta)
      rd_unit_gamma = rgamma(n = 3, shape = 100, scale = 0.01*unit_gamma)
      rd_unit_mu = rgamma(n = 3, shape = 100, scale = 0.01*unit_mu)
      
      generate_prob_br_all_dat=data.frame(matrix(NA, nrow = number_br, ncol = 3))
    
      for (j in 1:3){
      
      generate_prob_br <- MO_ternary(alpha,beta,rd_unit_theta[j],rd_unit_gamma[j],rd_unit_mu[j],initial_obs_0_1_recode[i,],sampletr)
      generate_prob_br_all_single <- c(generate_prob_br,rep(0,number_br-length(generate_prob_br)))
      generate_prob_br_all_dat[,j] = generate_prob_br_all_single}
      
      probs=rowMeans(generate_prob_br_all_dat, na.rm = FALSE, dims = 1)
      #find the MAP
      selected_br[i]=which.max(probs)
      #save the ith result to the matrix
      ternary_prob_matrix_all_0_1 = rbind(ternary_prob_matrix_all_0_1,probs)
      
    }

    # combine the true mutation branch and the inferred mutation branch for future comparison
    ternary_prob_matrix_all_0_1_rownames=cbind(mat_obs_form_0_1[,c(2,3)],selected_br,ternary_prob_matrix_all_0_1)
    # save inferred result for future comparison
    ternary_prob_matrix_all_0_1_out = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
    write.csv(ternary_prob_matrix_all_0_1_rownames,file=ternary_prob_matrix_all_0_1_out)
    
    
  }}


##############################################################################
#ternary 10 missing
#iteratively to run data in each setting
set.seed(20000)
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  unit_theta = 10^(-7) #rate from 0 to 1
  unit_gamma = 10^(-9) #rate from 0 to 2
  unit_mu = 10 ^(-2) #rate from 1 to 2
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  ternary_folder_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/Ternary_alpha0%s_beta0%s_result',alpha_str, beta_str)
  
  dir.create(ternary_folder_form)
  
  #in each setting, there are 100 trees, iteratively to estimate mutation order based on each tree
  for (indexn in 1:100){
    
    print(c(parameterIndex,indexn))
    
    # Tree_form is the tree file name
    Tree_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
    
    #scan and read the tree file into R 
    sampletr = read.tree(Tree_form)
    
    #read the simulated data into R
    obs_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_10Missing/Ternary_alpha0%s_beta0%s/ternary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
    mat_obs_form_0_1 = read.csv(obs_form)
    
    #recode the observed data for inference
    initial_obs_0_1 = data.frame(mat_obs_form_0_1[,-c(1,2,3)])
    
    #recode data
    initial_obs_0_1_recode = data.frame(matrix(,nrow=dim(initial_obs_0_1)[1],
                                               ncol=dim(initial_obs_0_1)[2]))
    
    for(rownum in 1:dim(initial_obs_0_1)[1]){
      for(colnum in 1:dim(initial_obs_0_1)[2])
        if(initial_obs_0_1[rownum,colnum] == "-"){
          initial_obs_0_1_recode[rownum,colnum] = 3 
          
        }else if(initial_obs_0_1[rownum,colnum] == "0"){initial_obs_0_1_recode[rownum,colnum] = 0
        }else if(initial_obs_0_1[rownum,colnum] == "1"){initial_obs_0_1_recode[rownum,colnum] = 1
        }else if(initial_obs_0_1[rownum,colnum] == "2"){initial_obs_0_1_recode[rownum,colnum] = 2
        } else{print("value does not exist")
        }
    }
    
    colnames(initial_obs_0_1_recode) = colnames(initial_obs_0_1)
    
    #initialize vector to store estimated probability and MAP estimates
    ternary_prob_matrix_all_0_1=c()
    selected_br=c()
    
    #compute probability that mutation i on each of the branches on the tree
    for (i in 1:dim(initial_obs_0_1_recode)[1]){

      rd_unit_theta =  rgamma(n = 3, shape = 100, scale = 0.01*unit_theta)
      rd_unit_gamma = rgamma(n = 3, shape = 100, scale = 0.01*unit_gamma)
      rd_unit_mu = rgamma(n = 3, shape = 100, scale = 0.01*unit_mu)
      
      generate_prob_br_all_dat=data.frame(matrix(NA, nrow = number_br, ncol = 3))
      
      for (j in 1:3){
        
        generate_prob_br <- MO_ternary(alpha,beta,rd_unit_theta[j],rd_unit_gamma[j],rd_unit_mu[j],initial_obs_0_1_recode[i,],sampletr)
        generate_prob_br_all_single <- c(generate_prob_br,rep(0,number_br-length(generate_prob_br)))
        generate_prob_br_all_dat[,j] = generate_prob_br_all_single}
      
      
      probs=rowMeans(generate_prob_br_all_dat, na.rm = FALSE, dims = 1)
      
      #find the MAP and save the ith result to the matrix
      selected_br[i]=which.max(probs)
      ternary_prob_matrix_all_0_1 = rbind(ternary_prob_matrix_all_0_1,probs)
    }

    #combine the true mutation branch and the inferred mutation branch for future comparison
    ternary_prob_matrix_all_0_1_rownames=cbind(mat_obs_form_0_1[,c(2,3)],selected_br,ternary_prob_matrix_all_0_1)
    #save inferred result for future comparison
    ternary_prob_matrix_all_0_1_out = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
    write.csv(ternary_prob_matrix_all_0_1_rownames,file=ternary_prob_matrix_all_0_1_out)
    
    
  }
  
}



##############################################################################

#ternary 20 missing
#iteratively to run data in each setting
set.seed(30000)
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  unit_theta = 10^(-7) #rate from 0 to 1
  unit_gamma = 10^(-9) #rate from 0 to 2
  unit_mu = 10 ^(-2) #rate from 1 to 2
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  ternary_folder_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/Ternary_alpha0%s_beta0%s_result',alpha_str, beta_str)
  dir.create(ternary_folder_form)
  
  #in each setting, there are 100 trees, iteratively to estimate mutation order based on each tree
  for (indexn in 1:100){
    
    print(c(parameterIndex,indexn))
    
    # Tree_form is the tree file name. Scan and read the tree file into R 
    Tree_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
    sampletr = read.tree(Tree_form)
    
    #read the simulated data into R
    obs_form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_20Missing/Ternary_alpha0%s_beta0%s/ternary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
    mat_obs_form_0_1 = read.csv(obs_form)
    
    #recode the observed data for inference
    initial_obs_0_1 = data.frame(mat_obs_form_0_1[,-c(1,2,3)])
    initial_obs_0_1_recode = data.frame(matrix(,nrow=dim(initial_obs_0_1)[1],
                                               ncol=dim(initial_obs_0_1)[2]))
    for(rownum in 1:dim(initial_obs_0_1)[1]){
      for(colnum in 1:dim(initial_obs_0_1)[2])
        
        if(initial_obs_0_1[rownum,colnum] == "-"){
          
          initial_obs_0_1_recode[rownum,colnum] = 3 }else if(initial_obs_0_1[rownum,colnum] == "0"){
          initial_obs_0_1_recode[rownum,colnum] = 0}else if(initial_obs_0_1[rownum,colnum] == "1"){
          initial_obs_0_1_recode[rownum,colnum] = 1}else if(initial_obs_0_1[rownum,colnum] == "2"){
          initial_obs_0_1_recode[rownum,colnum] = 2} else{print("value does not exist")}
    }
    
    colnames(initial_obs_0_1_recode) = colnames(initial_obs_0_1)
    
    #initialize vector to store estimated probability and MAP estimates
    ternary_prob_matrix_all_0_1=c()
    selected_br=c()
    
    #compute probability that mutation i on each of the branches on the tree
    for (i in 1:dim(initial_obs_0_1_recode)[1]){
      rd_unit_theta =  rgamma(n = 3, shape = 100, scale = 0.01*unit_theta)
      rd_unit_gamma = rgamma(n = 3, shape = 100, scale = 0.01*unit_gamma)
      rd_unit_mu = rgamma(n = 3, shape = 100, scale = 0.01*unit_mu)
      
      generate_prob_br_all_dat=data.frame(matrix(NA, nrow = number_br, ncol = 3))
      
      for (j in 1:3){
        
        generate_prob_br <- MO_ternary(alpha,beta,rd_unit_theta[j],rd_unit_gamma[j],rd_unit_mu[j],initial_obs_0_1_recode[i,],sampletr)
        generate_prob_br_all_single <- c(generate_prob_br,rep(0,number_br-length(generate_prob_br)))
        generate_prob_br_all_dat[,j] = generate_prob_br_all_single
        
      }
      probs=rowMeans(generate_prob_br_all_dat, na.rm = FALSE, dims = 1)
      
      #find the MAP
      selected_br[i]=which.max(probs)
      #save the ith result to the matrix
      ternary_prob_matrix_all_0_1 = rbind(ternary_prob_matrix_all_0_1,probs)
      
    }

    # combine the true mutation branch on column1 and the inferred mutation branch on column 3 for future comparison
    ternary_prob_matrix_all_0_1_rownames=cbind(mat_obs_form_0_1[,c(2,3)],selected_br,ternary_prob_matrix_all_0_1)
    # save inferred result for future comparison
    ternary_prob_matrix_all_0_1_out = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
    write.csv(ternary_prob_matrix_all_0_1_rownames,file=ternary_prob_matrix_all_0_1_out)}
  
}


```

Next, we can compute location accuracy for binary and ternary data from this setting:

```{r}
parameter_setting = expand.grid(alpha=c(0.05,0.1,0.2,0.4),
                                beta =c(0.05,0.1,0.2,0.4))
####################################################################################
#for binary data location accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
 

prob_cat_dat=data.frame(matrix(, nrow=0, ncol=4))

for (indexn in 1:100){
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #initialize a vector cat to store result: 0 means MAP estimate is different from true value, 1 means MAP estimate is the same as true value
  cat=rep(0,number_br)
  for (i in 1:dim(mat_prob_form_0_1)[1]){if(mat_prob_form_0_1$First_branch[i] == mat_prob_form_0_1$selected_br[i]){cat[i] = 1}}
  
  prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3,4)],cat)
  colnames(prob_cat_dat)=colnames(prob_cat_list)
  prob_cat_dat=rbind(prob_cat_dat,prob_cat_list)

}

prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/summary/binary_location_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(prob_cat_dat,file=prob_cat_list_0_1_out)
}

####################################################################################
#for binary data 10 missing location accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
prob_cat_dat=data.frame(matrix(, nrow=0, ncol=4))

for (indexn in 1:100){

  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)

  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #initialize a vector cat to store result: 0 means MAP estimate is different from true value, 1 means MAP estimate is the same as true value
  cat=rep(0,number_br)
  for (i in 1:dim(mat_prob_form_0_1)[1]){if(mat_prob_form_0_1$First_branch[i] == mat_prob_form_0_1$selected_br[i]){cat[i] = 1}}
  
  prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3,4)],cat)
  colnames(prob_cat_dat)=colnames(prob_cat_list)
  prob_cat_dat=rbind(prob_cat_dat,prob_cat_list)

}

prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/summary/binary_location_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(prob_cat_dat,file=prob_cat_list_0_1_out)
}

####################################################################################
#for binary data 20 missing location accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
prob_cat_dat=data.frame(matrix(, nrow=0, ncol=4))

for (indexn in 1:100){

  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)

  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #initialize a vector cat to store result: 0 means MAP estimate is different from true value, 1 means MAP estimate is the same as true value
  cat=rep(0,number_br)
  for (i in 1:dim(mat_prob_form_0_1)[1]){if(mat_prob_form_0_1$First_branch[i] == mat_prob_form_0_1$selected_br[i]){cat[i] = 1}}
  
  prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3,4)],cat)
  colnames(prob_cat_dat)=colnames(prob_cat_list)
  prob_cat_dat=rbind(prob_cat_dat,prob_cat_list)

}

prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/summary/binary_location_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(prob_cat_dat,file=prob_cat_list_0_1_out)
}

####################################################################################
#for ternary data location accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha = parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree

  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
prob_cat_dat=data.frame(matrix(, nrow=0, ncol=4))

for (indexn in 1:100){

  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  cat=rep(0,number_br)
  
  for (i in 1:dim(mat_prob_form_0_1)[1]){if(mat_prob_form_0_1$First_branch[i] == mat_prob_form_0_1$selected_br[i]){cat[i] = 1}}
  
  prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3,4)],cat)
  colnames(prob_cat_dat)=colnames(prob_cat_list)
  prob_cat_dat=rbind(prob_cat_dat,prob_cat_list)

}

prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/summary/ternary_location_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)

write.csv(prob_cat_dat,file=prob_cat_list_0_1_out)
}

####################################################################################
#for ternary data 10 missing location accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
prob_cat_dat=data.frame(matrix(, nrow=0, ncol=4))

for (indexn in 1:100){

  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  cat=rep(0,number_br)
  
  for (i in 1:dim(mat_prob_form_0_1)[1]){if(mat_prob_form_0_1$First_branch[i] == mat_prob_form_0_1$selected_br[i]){cat[i] = 1}}
  
  prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3,4)],cat)
  colnames(prob_cat_dat)=colnames(prob_cat_list)
  prob_cat_dat=rbind(prob_cat_dat,prob_cat_list)

}
prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/summary/ternary_location_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)

write.csv(prob_cat_dat,file=prob_cat_list_0_1_out)
}

####################################################################################
#for ternary data 20 missing location accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
prob_cat_dat=data.frame(matrix(, nrow=0, ncol=4))

for (indexn in 1:100){

  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  cat=rep(0,number_br)
  
  for (i in 1:dim(mat_prob_form_0_1)[1]){if(mat_prob_form_0_1$First_branch[i] == mat_prob_form_0_1$selected_br[i]){cat[i] = 1}}
  
  prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3,4)],cat)
  colnames(prob_cat_dat)=colnames(prob_cat_list)
  prob_cat_dat=rbind(prob_cat_dat,prob_cat_list)

}
prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/summary/ternary_location_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)

write.csv(prob_cat_dat,file=prob_cat_list_0_1_out)
}

```

We can compute interval accuracy for binary and ternary data from this setting:

```{r}
library(plyr)
library(ape)


parameter_setting = expand.grid(alpha=c(0.05,0.1,0.2,0.4),
                                beta =c(0.05,0.1,0.2,0.4))
####################################################################################
#for binary data interval accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  print(c(parameterIndex))
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

interval_prob_cat_dat=data.frame(matrix(, nrow=0, ncol=7))

for (indexn in 1:100){
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  true_obs_0_1 = as.matrix(mat_prob_form_0_1[,c(2)])
  true_obs_0_1_recoded= true_obs_0_1
  
  
  interval_cat_list=data.frame(cat=numeric(0))
  interval_prob_list=data.frame(interval_prob=numeric(0))
  interval_maxprob_list=data.frame(max_prob=numeric(0))
  interval_num_list=data.frame(prob_num=numeric(0))
  
  interval_indexn_list=data.frame(indexn=numeric(0))
  for (i in 1:dim(mat_prob_form_0_1)[1]){
    interval_indexn_list[i,]=indexn
    interval_maxprob_list[i,]=max(mat_prob_form_0_1[i,-c(1:4)])
    possible_br = which.max(mat_prob_form_0_1[i,-c(1:4)])
    reduced_mat_prob_form_0_1=(mat_prob_form_0_1[i,-c(1:4)])[,(which(colSums(mat_prob_form_0_1[i,-c(1:4)]) != 0))]
    
    true_obs_0_1_recoded_form=sprintf('X%s',true_obs_0_1_recoded[i])
    
    
    
    sorted_prob = sort(reduced_mat_prob_form_0_1,decreasing = TRUE)
    sorted_br = colnames(sorted_prob)
    sorted_sum = cumsum(t(sorted_prob))
    selected_br_num = which.min(abs(sorted_sum - 0.95))
    selected_br = as.factor(sorted_br[1:selected_br_num])
    selected_prob = sorted_sum[selected_br_num]
    selected_possible_br = as.factor(colnames(reduced_mat_prob_form_0_1)[which.max(reduced_mat_prob_form_0_1)])
    
    if (any(levels(selected_br) == (true_obs_0_1_recoded_form))){
                          interval_prob_list[i,] = selected_prob 
                          interval_cat_list[i,] = 1
                          interval_num_list[i,] = selected_br_num}else{
                            
                          interval_prob_list[i,] = selected_prob
                          interval_cat_list[i,] = 0
                          interval_num_list[i,] = selected_br_num}
    
  }
  
  interval_prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3)],interval_cat_list,interval_prob_list,interval_maxprob_list,interval_num_list,interval_indexn_list)
  colnames(interval_prob_cat_dat)=colnames(interval_prob_cat_list)
  interval_prob_cat_dat=rbind(interval_prob_cat_dat,interval_prob_cat_list)
 
  
}


prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/summary/binary_interval_alpha_0%s_beta_0%s_matrix.csv', alpha_str, beta_str)

write.csv(interval_prob_cat_dat,file=prob_cat_list_0_1_out)

}


####################################################################################
#for binary 10 missing data interval accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  print(c(parameterIndex))
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

interval_prob_cat_dat=data.frame(matrix(, nrow=0, ncol=7))

for (indexn in 1:100){
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  
  true_obs_0_1 = as.matrix(mat_prob_form_0_1[,c(2)])

  true_obs_0_1_recoded= true_obs_0_1
  
  
  interval_cat_list=data.frame(cat=numeric(0))
  interval_prob_list=data.frame(interval_prob=numeric(0))
  interval_maxprob_list=data.frame(max_prob=numeric(0))
  interval_num_list=data.frame(prob_num=numeric(0))
  
  interval_indexn_list=data.frame(indexn=numeric(0))
  for (i in 1:dim(mat_prob_form_0_1)[1]){
    
    
    interval_indexn_list[i,]=indexn
    interval_maxprob_list[i,]=max(mat_prob_form_0_1[i,-c(1:4)])
    possible_br = which.max(mat_prob_form_0_1[i,-c(1:4)])
    reduced_mat_prob_form_0_1=(mat_prob_form_0_1[i,-c(1:4)])[,(which(colSums(mat_prob_form_0_1[i,-c(1:4)]) != 0))]
    
    true_obs_0_1_recoded_form=sprintf('X%s',true_obs_0_1_recoded[i])
    
    
    
    sorted_prob = sort(reduced_mat_prob_form_0_1,decreasing = TRUE)
    sorted_br = colnames(sorted_prob)
    sorted_sum = cumsum(t(sorted_prob))
    selected_br_num = which.min(abs(sorted_sum - 0.95))
    selected_br = as.factor(sorted_br[1:selected_br_num])
    selected_prob = sorted_sum[selected_br_num]
    selected_possible_br = as.factor(colnames(reduced_mat_prob_form_0_1)[which.max(reduced_mat_prob_form_0_1)])
    
    if (any(levels(selected_br) == (true_obs_0_1_recoded_form))){
                          interval_prob_list[i,] = selected_prob 
                          interval_cat_list[i,] = 1
                          interval_num_list[i,] = selected_br_num}else{
                            
                          interval_prob_list[i,] = selected_prob
                          interval_cat_list[i,] = 0
                          interval_num_list[i,] = selected_br_num}
    
  }
  
  interval_prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3)],interval_cat_list,interval_prob_list,interval_maxprob_list,interval_num_list,interval_indexn_list)
  colnames(interval_prob_cat_dat)=colnames(interval_prob_cat_list)
  interval_prob_cat_dat=rbind(interval_prob_cat_dat,interval_prob_cat_list)
}


prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/summary/binary_interval_alpha_0%s_beta_0%s_matrix.csv', alpha_str, beta_str)
write.csv(interval_prob_cat_dat,file=prob_cat_list_0_1_out)
}


####################################################################################
#for binary 20 missing data interval accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  print(c(parameterIndex))
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

interval_prob_cat_dat=data.frame(matrix(, nrow=0, ncol=7))

for (indexn in 1:100){
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  
  true_obs_0_1 = as.matrix(mat_prob_form_0_1[,c(2)])

  true_obs_0_1_recoded= true_obs_0_1
  
  
  interval_cat_list=data.frame(cat=numeric(0))
  interval_prob_list=data.frame(interval_prob=numeric(0))
  interval_maxprob_list=data.frame(max_prob=numeric(0))
  interval_num_list=data.frame(prob_num=numeric(0))
  
  interval_indexn_list=data.frame(indexn=numeric(0))
  for (i in 1:dim(mat_prob_form_0_1)[1]){
    
    
    interval_indexn_list[i,]=indexn
    interval_maxprob_list[i,]=max(mat_prob_form_0_1[i,-c(1:4)])
    possible_br = which.max(mat_prob_form_0_1[i,-c(1:4)])
    reduced_mat_prob_form_0_1=(mat_prob_form_0_1[i,-c(1:4)])[,(which(colSums(mat_prob_form_0_1[i,-c(1:4)]) != 0))]
    
    true_obs_0_1_recoded_form=sprintf('X%s',true_obs_0_1_recoded[i])
    
    
    
    sorted_prob = sort(reduced_mat_prob_form_0_1,decreasing = TRUE)
    sorted_br = colnames(sorted_prob)
    sorted_sum = cumsum(t(sorted_prob))
    selected_br_num = which.min(abs(sorted_sum - 0.95))
    selected_br = as.factor(sorted_br[1:selected_br_num])
    selected_prob = sorted_sum[selected_br_num]
    selected_possible_br = as.factor(colnames(reduced_mat_prob_form_0_1)[which.max(reduced_mat_prob_form_0_1)])
    
    if (any(levels(selected_br) == (true_obs_0_1_recoded_form))){
                          interval_prob_list[i,] = selected_prob 
                          interval_cat_list[i,] = 1
                          interval_num_list[i,] = selected_br_num}else{
                            
                          interval_prob_list[i,] = selected_prob
                          interval_cat_list[i,] = 0
                          interval_num_list[i,] = selected_br_num}
    
  }
  
  interval_prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3)],interval_cat_list,interval_prob_list,interval_maxprob_list,interval_num_list,interval_indexn_list)
  colnames(interval_prob_cat_dat)=colnames(interval_prob_cat_list)
  interval_prob_cat_dat=rbind(interval_prob_cat_dat,interval_prob_cat_list)
}


prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/summary/binary_interval_alpha_0%s_beta_0%s_matrix.csv', alpha_str, beta_str)
write.csv(interval_prob_cat_dat,file=prob_cat_list_0_1_out)
}


####################################################################################
#for ternary data interval accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  
  print(c(parameterIndex))
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

interval_prob_cat_dat=data.frame(matrix(, nrow=0, ncol=7))

for (indexn in 1:100){
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  
  true_obs_0_1 = as.matrix(mat_prob_form_0_1[,c(2)])

  true_obs_0_1_recoded= true_obs_0_1
  
  
  interval_cat_list=data.frame(cat=numeric(0))
  interval_prob_list=data.frame(interval_prob=numeric(0))
  interval_maxprob_list=data.frame(max_prob=numeric(0))
  interval_num_list=data.frame(prob_num=numeric(0))
  
  interval_indexn_list=data.frame(indexn=numeric(0))
  for (i in 1:dim(mat_prob_form_0_1)[1]){
    
    
    interval_indexn_list[i,]=indexn
    interval_maxprob_list[i,]=max(mat_prob_form_0_1[i,-c(1:4)])
    possible_br = which.max(mat_prob_form_0_1[i,-c(1:4)])
    reduced_mat_prob_form_0_1=(mat_prob_form_0_1[i,-c(1:4)])[,(which(colSums(mat_prob_form_0_1[i,-c(1:4)]) != 0))]
    
    true_obs_0_1_recoded_form=sprintf('X%s',true_obs_0_1_recoded[i])
    
    
    
    sorted_prob = sort(reduced_mat_prob_form_0_1,decreasing = TRUE)
    sorted_br = colnames(sorted_prob)
    sorted_sum = cumsum(t(sorted_prob))
    selected_br_num = which.min(abs(sorted_sum - 0.95))
    selected_br = as.factor(sorted_br[1:selected_br_num])
    selected_prob = sorted_sum[selected_br_num]
    selected_possible_br = as.factor(colnames(reduced_mat_prob_form_0_1)[which.max(reduced_mat_prob_form_0_1)])
    
    if (any(levels(selected_br) == (true_obs_0_1_recoded_form))){
                          interval_prob_list[i,] = selected_prob 
                          interval_cat_list[i,] = 1
                          interval_num_list[i,] = selected_br_num}else{
                            
                          interval_prob_list[i,] = selected_prob
                          interval_cat_list[i,] = 0
                          interval_num_list[i,] = selected_br_num}
    
  }
  
  interval_prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3)],interval_cat_list,interval_prob_list,interval_maxprob_list,interval_num_list,interval_indexn_list)
  colnames(interval_prob_cat_dat)=colnames(interval_prob_cat_list)
  interval_prob_cat_dat=rbind(interval_prob_cat_dat,interval_prob_cat_list)
 
  
}


prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/summary/ternary_interval_alpha_0%s_beta_0%s_matrix.csv', alpha_str, beta_str)

write.csv(interval_prob_cat_dat,file=prob_cat_list_0_1_out)

}


####################################################################################
#for ternary 10 missing data interval accuracy

for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  
  print(c(parameterIndex))
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

interval_prob_cat_dat=data.frame(matrix(, nrow=0, ncol=7))

for (indexn in 1:100){
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  true_obs_0_1 = as.matrix(mat_prob_form_0_1[,c(2)])
  true_obs_0_1_recoded= true_obs_0_1
  
  
  interval_cat_list=data.frame(cat=numeric(0))
  interval_prob_list=data.frame(interval_prob=numeric(0))
  interval_maxprob_list=data.frame(max_prob=numeric(0))
  interval_num_list=data.frame(prob_num=numeric(0))
  
  interval_indexn_list=data.frame(indexn=numeric(0))
  for (i in 1:dim(mat_prob_form_0_1)[1]){
    
    
    interval_indexn_list[i,]=indexn
    interval_maxprob_list[i,]=max(mat_prob_form_0_1[i,-c(1:4)])
    possible_br = which.max(mat_prob_form_0_1[i,-c(1:4)])
    reduced_mat_prob_form_0_1=(mat_prob_form_0_1[i,-c(1:4)])[,(which(colSums(mat_prob_form_0_1[i,-c(1:4)]) != 0))]
    
    true_obs_0_1_recoded_form=sprintf('X%s',true_obs_0_1_recoded[i])
    
    sorted_prob = sort(reduced_mat_prob_form_0_1,decreasing = TRUE)
    sorted_br = colnames(sorted_prob)
    sorted_sum = cumsum(t(sorted_prob))
    selected_br_num = which.min(abs(sorted_sum - 0.95))
    selected_br = as.factor(sorted_br[1:selected_br_num])
    selected_prob = sorted_sum[selected_br_num]
    selected_possible_br = as.factor(colnames(reduced_mat_prob_form_0_1)[which.max(reduced_mat_prob_form_0_1)])
    
    if (any(levels(selected_br) == (true_obs_0_1_recoded_form))){
                          interval_prob_list[i,] = selected_prob 
                          interval_cat_list[i,] = 1
                          interval_num_list[i,] = selected_br_num}else{
                            
                          interval_prob_list[i,] = selected_prob
                          interval_cat_list[i,] = 0
                          interval_num_list[i,] = selected_br_num}
    
  }
  
  interval_prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3)],interval_cat_list,interval_prob_list,interval_maxprob_list,interval_num_list,interval_indexn_list)
  colnames(interval_prob_cat_dat)=colnames(interval_prob_cat_list)
  interval_prob_cat_dat=rbind(interval_prob_cat_dat,interval_prob_cat_list)
 
  
}


prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/summary/ternary_interval_alpha_0%s_beta_0%s_matrix.csv', alpha_str, beta_str)

write.csv(interval_prob_cat_dat,file=prob_cat_list_0_1_out)

}


####################################################################################
#for ternary 10 missing data interval accuracy

for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  
  print(c(parameterIndex))
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

interval_prob_cat_dat=data.frame(matrix(, nrow=0, ncol=7))

for (indexn in 1:100){
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  
  prob_form_0_1 = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  true_obs_0_1 = as.matrix(mat_prob_form_0_1[,c(2)])
  true_obs_0_1_recoded= true_obs_0_1
  
  
  interval_cat_list=data.frame(cat=numeric(0))
  interval_prob_list=data.frame(interval_prob=numeric(0))
  interval_maxprob_list=data.frame(max_prob=numeric(0))
  interval_num_list=data.frame(prob_num=numeric(0))
  
  interval_indexn_list=data.frame(indexn=numeric(0))
  for (i in 1:dim(mat_prob_form_0_1)[1]){
    
    
    interval_indexn_list[i,]=indexn
    interval_maxprob_list[i,]=max(mat_prob_form_0_1[i,-c(1:4)])
    possible_br = which.max(mat_prob_form_0_1[i,-c(1:4)])
    reduced_mat_prob_form_0_1=(mat_prob_form_0_1[i,-c(1:4)])[,(which(colSums(mat_prob_form_0_1[i,-c(1:4)]) != 0))]
    
    true_obs_0_1_recoded_form=sprintf('X%s',true_obs_0_1_recoded[i])
    
    sorted_prob = sort(reduced_mat_prob_form_0_1,decreasing = TRUE)
    sorted_br = colnames(sorted_prob)
    sorted_sum = cumsum(t(sorted_prob))
    selected_br_num = which.min(abs(sorted_sum - 0.95))
    selected_br = as.factor(sorted_br[1:selected_br_num])
    selected_prob = sorted_sum[selected_br_num]
    selected_possible_br = as.factor(colnames(reduced_mat_prob_form_0_1)[which.max(reduced_mat_prob_form_0_1)])
    
    if (any(levels(selected_br) == (true_obs_0_1_recoded_form))){
                          interval_prob_list[i,] = selected_prob 
                          interval_cat_list[i,] = 1
                          interval_num_list[i,] = selected_br_num}else{
                            
                          interval_prob_list[i,] = selected_prob
                          interval_cat_list[i,] = 0
                          interval_num_list[i,] = selected_br_num}
    
  }
  
  interval_prob_cat_list = cbind(mat_prob_form_0_1[,c(2,3)],interval_cat_list,interval_prob_list,interval_maxprob_list,interval_num_list,interval_indexn_list)
  colnames(interval_prob_cat_dat)=colnames(interval_prob_cat_list)
  interval_prob_cat_dat=rbind(interval_prob_cat_dat,interval_prob_cat_list)
 
  
}


prob_cat_list_0_1_out = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/summary/ternary_interval_alpha_0%s_beta_0%s_matrix.csv', alpha_str, beta_str)

write.csv(interval_prob_cat_dat,file=prob_cat_list_0_1_out)

}


```

We can compute the order accuracy.

```{r}
library(plyr)
library(ape)
compare_all_order <- function(number_br,number_cell,ts){
  
  ####################################################################################################
  ####################################################################################################
  #extract the tree, if mutation is on one branch, then the corresponding tips will have mutation
  ####################################################################################################
  ####################################################################################################
  
  left_right <- function(edge,parent){
    child = c()
    for (i in 1:nrow(edge)) {
      if (edge[i,1] == parent) {
        child = c(child,edge[i,2])
      }
    }
    return(child)
  }
  
  build_tree <- function(edge,branch){
    child_node = left_right(edge,branch[length(branch)])
    new_branch=matrix(c(branch,child_node[1],branch,child_node[2]),nrow=2,byrow = TRUE)
    return(new_branch)
  }
  
  #####################################modify begin################################
  # find node parent
  find_ancestor <- function(edge,node){
    parent = 0
    for (i in 1:nrow(edge)) {
      if (edge[i,2] == node) {
        parent = edge[i,1]
      }
    }
    return(parent)
  }
  
  # get all unique nodes in the tree
  get_all_nodes <- function(edge)
  {
    all_nodes = integer(length(edge))
    for (i in 1:nrow(edge))
    {
      all_nodes[(i-1)*2+1] = edge[i,1]
      all_nodes[(i-1)*2+2] = edge[i,2]
    }
    all_nodes = unique(all_nodes)
    return(all_nodes)
  }
  
  # find root node
  find_root <- function(edge)
  {
    all_nodes = get_all_nodes(edge)
    
    for (i in 1:length(all_nodes))
    {
      parent = find_ancestor(edge, all_nodes[i])
      if (parent == 0)
      {
        root_node = all_nodes[i]
        break
      }
    }
  }
  
  # find two child branches and nodes if they exist. Otherwise all zeros matrix output
  find_child_branches_and_nodes <- function(edge, parent_node){
    child_branches_and_nodes = matrix(0, 2, 2)
    child_id = 1
    # first row are two nodes, second row are two branches
    for (i in 1:nrow(edge))
    {
      if (edge[i,1] == parent_node) {
        child_branches_and_nodes[1,child_id] = edge[i,2]
        child_branches_and_nodes[2,child_id] = i
        child_id = child_id + 1
      }
    }
    
    return(child_branches_and_nodes)
  }
  
  # find all child branch for current branch
  find_child_branches <- function(edge, current_edge, child_branches)
  {
    id = length(child_branches)
    right_node = edge[current_edge, 2]
    
    child_branches_and_nodes = find_child_branches_and_nodes(edge, right_node)
    
    if (child_branches_and_nodes[1,1] != 0)
    {
      # if not leaf node
      left_node = child_branches_and_nodes[1,1]
      right_node = child_branches_and_nodes[1,2]
      left_branch = child_branches_and_nodes[2,1]
      right_branch = child_branches_and_nodes[2,2]
      
      id = id + 1
      child_branches[id] = left_branch
      id = id + 1
      child_branches[id] = right_branch
      
      child_branches = find_child_branches(edge, left_branch, child_branches)
      child_branches = find_child_branches(edge, right_branch, child_branches)
      
      return(child_branches)
      
    }
    else
    {
      return(child_branches)
    }
    
  }
  
  # find all child branch for all branches
  find_all_child_branches <- function(edge){
    # get root node
    root_node = find_root(edge)
    
    all_child_branches = rep(list(list()), nrow(edge)) 
    
    for (i in 1:nrow(edge))
    {
      current_edge = i
      # iterative find all its child branches
      child_branches = integer(0)
      all_child_branches[[i]] = find_child_branches(edge, current_edge, child_branches)
      
    }
    
    return(all_child_branches)
  }
  
  
  
  all_child_branches =  find_all_child_branches(ts$edge)
  
  
  return(all_child_branches=all_child_branches)
  
  
  
  
}

parameter_setting = expand.grid(alpha=c(0.05,0.1,0.2,0.4),
                                beta =c(0.05,0.1,0.2,0.4))
####################################################################################
#for binary data order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  

all_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New/Binary_alpha0%s_beta0%s/binary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find descent branches of each br
  true_all_branch = compare_all_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_all_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_all_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all paired branches in a dataframe
  for (br in 1:length(true_all_branch)){
    
    if(length(true_all_branch[[br]])>0){
      for(br_sub in 1:length(true_all_branch[[br]])){
        all_true_all_branch = rbind(all_true_all_branch,c(br,(true_all_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_all_branch_sub = na.omit(all_true_all_branch)
  exclude_branch = setdiff(c(1:number_br), mat_prob_form_0_1$First_branch)
  
  colnames(all_true_all_branch_sub) = c("first_br_indexn","second_br_indexn")
  
 
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
    }
    }else {
      
    for(rm in 1:length(exclude_branch)){
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
    }
  
  
  for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
  }
  }
    
  all_pair_result[indexn,]=c(dim(all_match_all_branch_sub)[1],dim(all_true_all_branch_sub)[1])
  
}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/summary/binary_all_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(all_pair_result,file=all_pair_result_form_0_1)

}

####################################################################################
#for binary 10 missing data order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  unit_theta = 10^(-7) #rate from 0 to 1
  unit_gamma = 10^(-9) #rate from 0 to 2
  unit_mu = 10 ^(-2) #rate from 1 to 2
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  

all_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_10Missing/Binary_alpha0%s_beta0%s/binary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find descent branches of each br
  true_all_branch = compare_all_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_all_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_all_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all paired branches in a dataframe
  for (br in 1:length(true_all_branch)){
    
    if(length(true_all_branch[[br]])>0){
      for(br_sub in 1:length(true_all_branch[[br]])){
        all_true_all_branch = rbind(all_true_all_branch,c(br,(true_all_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_all_branch_sub = na.omit(all_true_all_branch)
  exclude_branch = setdiff(c(1:number_br), mat_prob_form_0_1$First_branch)
  
  colnames(all_true_all_branch_sub) = c("first_br_indexn","second_br_indexn")
  
 
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
    }
    }else {
      
    for(rm in 1:length(exclude_branch)){
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
    }
  
  
  for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
  }
  }
    
  all_pair_result[indexn,]=c(dim(all_match_all_branch_sub)[1],dim(all_true_all_branch_sub)[1])
  
}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/summary/binary_all_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(all_pair_result,file=all_pair_result_form_0_1)

}


####################################################################################
#for binary 20 missing data order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  unit_theta = 10^(-7) #rate from 0 to 1
  unit_gamma = 10^(-9) #rate from 0 to 2
  unit_mu = 10 ^(-2) #rate from 1 to 2
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  

all_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_20Missing/Binary_alpha0%s_beta0%s/binary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find descent branches of each br
  true_all_branch = compare_all_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_all_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_all_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all paired branches in a dataframe
  for (br in 1:length(true_all_branch)){
    
    if(length(true_all_branch[[br]])>0){
      for(br_sub in 1:length(true_all_branch[[br]])){
        all_true_all_branch = rbind(all_true_all_branch,c(br,(true_all_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_all_branch_sub = na.omit(all_true_all_branch)
  exclude_branch = setdiff(c(1:number_br), mat_prob_form_0_1$First_branch)
  
  colnames(all_true_all_branch_sub) = c("first_br_indexn","second_br_indexn")
  
 
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
    }
    }else {
      
    for(rm in 1:length(exclude_branch)){
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
    }
  
  
  for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
  }
  }
    
  all_pair_result[indexn,]=c(dim(all_match_all_branch_sub)[1],dim(all_true_all_branch_sub)[1])
  
}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/summary/binary_all_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(all_pair_result,file=all_pair_result_form_0_1)

}

####################################################################################
#for ternary data order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  

all_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New/Ternary_alpha0%s_beta0%s/ternary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find descent branches of each br
  true_all_branch = compare_all_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_all_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_all_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all paired branches in a dataframe
  for (br in 1:length(true_all_branch)){
    
    if(length(true_all_branch[[br]])>0){
      for(br_sub in 1:length(true_all_branch[[br]])){
        all_true_all_branch = rbind(all_true_all_branch,c(br,(true_all_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_all_branch_sub = na.omit(all_true_all_branch)
  exclude_branch = setdiff(c(1:18), mat_prob_form_0_1$First_branch)
  
  colnames(all_true_all_branch_sub) = c("first_br_indexn","second_br_indexn")
  
 
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
    }
    }else {
      
    for(rm in 1:length(exclude_branch)){
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
    }
  
  
  for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
  }
  }
    
  all_pair_result[indexn,]=c(dim(all_match_all_branch_sub)[1],dim(all_true_all_branch_sub)[1])
  
}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/summary/ternary_all_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(all_pair_result,file=all_pair_result_form_0_1)

}

####################################################################################
#for ternary 10 missing data order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  

all_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_10Missing/Ternary_alpha0%s_beta0%s/ternary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find descent branches of each br
  true_all_branch = compare_all_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_all_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_all_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all paired branches in a dataframe
  for (br in 1:length(true_all_branch)){
    
    if(length(true_all_branch[[br]])>0){
      for(br_sub in 1:length(true_all_branch[[br]])){
        all_true_all_branch = rbind(all_true_all_branch,c(br,(true_all_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_all_branch_sub = na.omit(all_true_all_branch)
  exclude_branch = setdiff(c(1:18), mat_prob_form_0_1$First_branch)
  
  colnames(all_true_all_branch_sub) = c("first_br_indexn","second_br_indexn")
  
 
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
    }
    }else {
      
    for(rm in 1:length(exclude_branch)){
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
    }
  
  
  for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
  }
  }
    
  all_pair_result[indexn,]=c(dim(all_match_all_branch_sub)[1],dim(all_true_all_branch_sub)[1])
  
}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/summary/ternary_all_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(all_pair_result,file=all_pair_result_form_0_1)

}

####################################################################################
#for ternary 20 missing data order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  

all_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_20Missing/Ternary_alpha0%s_beta0%s/ternary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find descent branches of each br
  true_all_branch = compare_all_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_all_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_all_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all paired branches in a dataframe
  for (br in 1:length(true_all_branch)){
    
    if(length(true_all_branch[[br]])>0){
      for(br_sub in 1:length(true_all_branch[[br]])){
        all_true_all_branch = rbind(all_true_all_branch,c(br,(true_all_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_all_branch_sub = na.omit(all_true_all_branch)
  exclude_branch = setdiff(c(1:18), mat_prob_form_0_1$First_branch)
  
  colnames(all_true_all_branch_sub) = c("first_br_indexn","second_br_indexn")
  
 
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
    }
    }else {
      
    for(rm in 1:length(exclude_branch)){
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
      all_true_all_branch_sub<-all_true_all_branch_sub[!(all_true_all_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
    }
  
  
  for (i in 1:dim(all_true_all_branch_sub)[1]){
    
    print(c(indexn,i))
    
    
    first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,1]),])[,-c(1,2,3,4)])
    second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_all_branch_sub[i,2]),])[,-c(1,2,3,4)])
    
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_all_branch_sub, br_indexn)
    
    all_match_all_branch_sub=rbind(all_match_all_branch_sub, matchresult)
  }
  }
    
  all_pair_result[indexn,]=c(dim(all_match_all_branch_sub)[1],dim(all_true_all_branch_sub)[1])
  
}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/summary/ternary_all_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(all_pair_result,file=all_pair_result_form_0_1)

}

```

Then, we estimate the adjacent accuracy for the data we generated above:

```{r}
library(plyr)
library(ape)
compare_near_order <- function(number_br,number_cell,ts){
  
  ####################################################################################################
  ####################################################################################################
  #extract the tree, if mutation is on one branch, then the corresponding tips will have mutation
  ####################################################################################################
  ####################################################################################################
  
  left_right <- function(edge,parent){
    child = c()
    for (i in 1:nrow(edge)) {
      if (edge[i,1] == parent) {
        child = c(child,edge[i,2])
      }
    }
    return(child)
  }
  
  build_tree <- function(edge,branch){
    child_node = left_right(edge,branch[length(branch)])
    new_branch=matrix(c(branch,child_node[1],branch,child_node[2]),nrow=2,byrow = TRUE)
    return(new_branch)
  }
  
  #####################################modify begin################################
  # find node parent
  find_ancestor <- function(edge,node){
    parent = 0
    for (i in 1:nrow(edge)) {
      if (edge[i,2] == node) {
        parent = edge[i,1]
      }
    }
    return(parent)
  }
  
  # get all unique nodes in the tree
  get_all_nodes <- function(edge)
  {
    all_nodes = integer(length(edge))
    for (i in 1:nrow(edge))
    {
      all_nodes[(i-1)*2+1] = edge[i,1]
      all_nodes[(i-1)*2+2] = edge[i,2]
    }
    all_nodes = unique(all_nodes)
    return(all_nodes)
  }
  
  # find root node
  find_root <- function(edge)
  {
    all_nodes = get_all_nodes(edge)
    
    for (i in 1:length(all_nodes))
    {
      parent = find_ancestor(edge, all_nodes[i])
      if (parent == 0)
      {
        root_node = all_nodes[i]
        break
      }
    }
  }
  
  # find two child branches and nodes if they exist. Otherwise all zeros matrix output
  find_child_branches_and_nodes <- function(edge, parent_node){
    child_branches_and_nodes = matrix(0, 2, 2)
    child_id = 1
    # first row are two nodes, second row are two branches
    for (i in 1:nrow(edge))
    {
      if (edge[i,1] == parent_node) {
        child_branches_and_nodes[1,child_id] = edge[i,2]
        child_branches_and_nodes[2,child_id] = i
        child_id = child_id + 1
      }
    }
    
    return(child_branches_and_nodes)
  }
  
  # find all child branch for current branch
  find_child_branches <- function(edge, current_edge, child_branches)
  {
    id = length(child_branches)
    right_node = edge[current_edge, 2]
    
    child_branches_and_nodes = find_child_branches_and_nodes(edge, right_node)
    
    if (child_branches_and_nodes[1,1] != 0)
    {
      # if not leaf node
      left_node = child_branches_and_nodes[1,1]
      right_node = child_branches_and_nodes[1,2]
      left_branch = child_branches_and_nodes[2,1]
      right_branch = child_branches_and_nodes[2,2]
      
      id = id + 1
      child_branches[id] = left_branch
      id = id + 1
      child_branches[id] = right_branch
      
      child_branches = find_child_branches(edge, left_branch, child_branches)
      child_branches = find_child_branches(edge, right_branch, child_branches)
      
      return(child_branches)
      
    }
    else
    {
      return(child_branches)
    }
    
  }
  
  # find all child branch for all branches
  find_all_child_branches <- function(edge){
    # get root node
    root_node = find_root(edge)
    
    all_child_branches = rep(list(list()), nrow(edge)) 
    
    for (i in 1:nrow(edge))
    {
      current_edge = i
      # iterative find all its child branches
      child_branches = integer(0)
      all_child_branches[[i]] = find_child_branches(edge, current_edge, child_branches)
      
    }
    
    return(all_child_branches)
  }
  
  
  # find neighboring child branch for current branch
  find_neighboring_child_branches <- function(edge, current_edge, child_branches)
  {
    id = length(child_branches)
    right_node = edge[current_edge, 2]
    
    child_branches_and_nodes = find_child_branches_and_nodes(edge, right_node)
    
    if (child_branches_and_nodes[1,1] != 0)
    {
      # if not leaf node
      left_node = child_branches_and_nodes[1,1]
      right_node = child_branches_and_nodes[1,2]
      left_branch = child_branches_and_nodes[2,1]
      right_branch = child_branches_and_nodes[2,2]
      
      id = id + 1
      child_branches[id] = left_branch
      id = id + 1
      child_branches[id] = right_branch
      
      return(child_branches)
    }
    else
    {
      return(child_branches)
    }
    
  }
  
  # find following child branch for all branches
  find_all_neighboring_child_branches <- function(edge){
    neighbor_child_branches = rep(list(list()), nrow(edge)) 
    
    for (i in 1:nrow(edge))
    {
      current_edge = i
      # iterative find all its child branches
      child_branches = integer(0)
      neighbor_child_branches[[i]] = find_neighboring_child_branches(edge, current_edge, child_branches)
      
    }
    
    return(neighbor_child_branches)
  }
  
  neighboring_child_branches = find_all_neighboring_child_branches(ts$edge)
  
  
  return(neighboring_child_branches=neighboring_child_branches)
  
  
  
  
}


parameter_setting = expand.grid(alpha=c(0.05,0.1,0.2,0.4),
                                beta =c(0.05,0.1,0.2,0.4))
#######################################################
#for binary data adjacent order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

adjacent_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New/Binary_alpha0%s_beta0%s/binary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find children branches of each br
  true_near_branch = compare_near_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_near_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_near_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all adjacent paired branches in a dataframe
  for (br in 1:length(true_near_branch)){
    
    if(length(true_near_branch[[br]])>0){
      for(br_sub in 1:length(true_near_branch[[br]])){
        all_true_near_branch = rbind(all_true_near_branch,c(br,(true_near_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_near_branch_sub=na.omit(all_true_near_branch)
  colnames(all_true_near_branch_sub) = c("first_br_indexn","second_br_indexn")
  exclude_branch = setdiff(c(1:number_br), mat_prob_form_0_1$First_branch)
  
  
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_near_branch_sub)[1]){
    
    print(c(indexn,i))
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,1],-c(1,2,3,4)]))
    second_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,2],-c(1,2,3,4)]))
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_near_branch_sub, br_indexn)
    
    all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }
    
    }else {
    
      
      for(rm in 1:length(exclude_branch)){
      
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
      }
    
    
      for(i in 1:dim(all_true_near_branch_sub)[1]){
      
      print(c(indexn,i))
      
      
      first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,1]),])[,-c(1,2,3,4)])
      second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,2]),])[,-c(1,2,3,4)])
      
      br_indexn=data.frame(first_br_indexn,second_br_indexn)
      
      matchresult = match_df(all_true_near_branch_sub, br_indexn)
      
      all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }}
    
  
  adjacent_pair_result[indexn,]=c(dim(all_match_near_branch_sub)[1],dim(all_true_near_branch_sub)[1])
  
}


adjacent_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary/summary/binary_adjacent_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(adjacent_pair_result,file=adjacent_pair_result_form_0_1)


}

######################################################
#for binary 10 missing data adjacent order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

adjacent_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_10Missing/Binary_alpha0%s_beta0%s/binary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find children branches of each br
  true_near_branch = compare_near_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_near_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_near_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all adjacent paired branches in a dataframe
  for (br in 1:length(true_near_branch)){
    
    if(length(true_near_branch[[br]])>0){
      for(br_sub in 1:length(true_near_branch[[br]])){
        all_true_near_branch = rbind(all_true_near_branch,c(br,(true_near_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_near_branch_sub=na.omit(all_true_near_branch)
  colnames(all_true_near_branch_sub) = c("first_br_indexn","second_br_indexn")
  exclude_branch = setdiff(c(1:18), mat_prob_form_0_1$First_branch)
  
  
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_near_branch_sub)[1]){
    
    print(c(indexn,i))
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,1],-c(1,2,3,4)]))
    second_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,2],-c(1,2,3,4)]))
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_near_branch_sub, br_indexn)
    
    all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }
    
    }else {
    
      
      for(rm in 1:length(exclude_branch)){
      
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
      }
    
    
      for(i in 1:dim(all_true_near_branch_sub)[1]){
      
      print(c(indexn,i))
      
      
      first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,1]),])[,-c(1,2,3,4)])
      second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,2]),])[,-c(1,2,3,4)])
      
      br_indexn=data.frame(first_br_indexn,second_br_indexn)
      
      matchresult = match_df(all_true_near_branch_sub, br_indexn)
      
      all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }}
    
  
  adjacent_pair_result[indexn,]=c(dim(all_match_near_branch_sub)[1],dim(all_true_near_branch_sub)[1])
  
}


adjacent_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_10missing/summary/binary_adjacent_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(adjacent_pair_result,file=adjacent_pair_result_form_0_1)


}

######################################################
#for binary 20 missing data adjacent order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

adjacent_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_20Missing/Binary_alpha0%s_beta0%s/binary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/Binary_alpha0%s_beta0%s_result/all_binary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find children branches of each br
  true_near_branch = compare_near_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_near_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_near_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all adjacent paired branches in a dataframe
  for (br in 1:length(true_near_branch)){
    
    if(length(true_near_branch[[br]])>0){
      for(br_sub in 1:length(true_near_branch[[br]])){
        all_true_near_branch = rbind(all_true_near_branch,c(br,(true_near_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_near_branch_sub=na.omit(all_true_near_branch)
  colnames(all_true_near_branch_sub) = c("first_br_indexn","second_br_indexn")
  exclude_branch = setdiff(c(1:18), mat_prob_form_0_1$First_branch)
  
  
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_near_branch_sub)[1]){
    
    print(c(indexn,i))
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,1],-c(1,2,3,4)]))
    second_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,2],-c(1,2,3,4)]))
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_near_branch_sub, br_indexn)
    
    all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }
    
    }else {
    
      
      for(rm in 1:length(exclude_branch)){
      
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
      }
    
    
      for(i in 1:dim(all_true_near_branch_sub)[1]){
      
      print(c(indexn,i))
      
      
      first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,1]),])[,-c(1,2,3,4)])
      second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,2]),])[,-c(1,2,3,4)])
      
      br_indexn=data.frame(first_br_indexn,second_br_indexn)
      
      matchresult = match_df(all_true_near_branch_sub, br_indexn)
      
      all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }}
    
  
  adjacent_pair_result[indexn,]=c(dim(all_match_near_branch_sub)[1],dim(all_true_near_branch_sub)[1])
  
}


adjacent_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Binary_20missing/summary/binary_adjacent_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(adjacent_pair_result,file=adjacent_pair_result_form_0_1)


}

######################################################
#for ternary data adjacent order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

adjacent_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New/Ternary_alpha0%s_beta0%s/ternary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find children branches of each br
  true_near_branch = compare_near_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_near_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_near_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all adjacent paired branches in a dataframe
  for (br in 1:length(true_near_branch)){
    
    if(length(true_near_branch[[br]])>0){
      for(br_sub in 1:length(true_near_branch[[br]])){
        all_true_near_branch = rbind(all_true_near_branch,c(br,(true_near_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_near_branch_sub=na.omit(all_true_near_branch)
  colnames(all_true_near_branch_sub) = c("first_br_indexn","second_br_indexn")
  exclude_branch = setdiff(c(1:18), mat_prob_form_0_1$First_branch)
  
  
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_near_branch_sub)[1]){
    
    print(c(indexn,i))
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,1],-c(1,2,3,4)]))
    second_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,2],-c(1,2,3,4)]))
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_near_branch_sub, br_indexn)
    
    all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }
    
    }else {
    
      
      for(rm in 1:length(exclude_branch)){
      
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
      }
    
    
      for(i in 1:dim(all_true_near_branch_sub)[1]){
      
      print(c(indexn,i))
      
      
      first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,1]),])[,-c(1,2,3,4)])
      second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,2]),])[,-c(1,2,3,4)])
      
      br_indexn=data.frame(first_br_indexn,second_br_indexn)
      
      matchresult = match_df(all_true_near_branch_sub, br_indexn)
      
      all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }}
    
  
  adjacent_pair_result[indexn,]=c(dim(all_match_near_branch_sub)[1],dim(all_true_near_branch_sub)[1])
  
}


adjacent_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary/summary/ternary_adjacent_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(adjacent_pair_result,file=adjacent_pair_result_form_0_1)


}

######################################################
#for ternary 10 missing data adjacent order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

adjacent_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_10Missing/Ternary_alpha0%s_beta0%s/ternary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find children branches of each br
  true_near_branch = compare_near_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_near_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_near_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all adjacent paired branches in a dataframe
  for (br in 1:length(true_near_branch)){
    
    if(length(true_near_branch[[br]])>0){
      for(br_sub in 1:length(true_near_branch[[br]])){
        all_true_near_branch = rbind(all_true_near_branch,c(br,(true_near_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_near_branch_sub=na.omit(all_true_near_branch)
  colnames(all_true_near_branch_sub) = c("first_br_indexn","second_br_indexn")
  exclude_branch = setdiff(c(1:18), mat_prob_form_0_1$First_branch)
  
  
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_near_branch_sub)[1]){
    
    print(c(indexn,i))
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,1],-c(1,2,3,4)]))
    second_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,2],-c(1,2,3,4)]))
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_near_branch_sub, br_indexn)
    
    all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }
    
    }else {
    
      
      for(rm in 1:length(exclude_branch)){
      
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
      }
    
    
      for(i in 1:dim(all_true_near_branch_sub)[1]){
      
      print(c(indexn,i))
      
      
      first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,1]),])[,-c(1,2,3,4)])
      second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,2]),])[,-c(1,2,3,4)])
      
      br_indexn=data.frame(first_br_indexn,second_br_indexn)
      
      matchresult = match_df(all_true_near_branch_sub, br_indexn)
      
      all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }}
    
  
  adjacent_pair_result[indexn,]=c(dim(all_match_near_branch_sub)[1],dim(all_true_near_branch_sub)[1])
  
}


adjacent_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_10missing/summary/ternary_adjacent_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(adjacent_pair_result,file=adjacent_pair_result_form_0_1)


}


######################################################
#for ternary 20 missing data adjacent order accuracy
for(parameterIndex in 1:dim(parameter_setting)[1]){
  
  #get the parameters in each setting
  alpha =   parameter_setting[parameterIndex,1]#fpr
  beta = parameter_setting[parameterIndex,2]#fnr
  number_br = 18 #number of branches in a tree
  number_cell = 10 #number of cells in a tree
  
  #return alpha and beta string used for data input
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  

adjacent_pair_result= data.frame(matrix(, nrow=0, ncol=2))

for (indexn in 1:100){
  
  
  form = sprintf('./Figures3_4_Scenarios1_2/Scenario1/RandomTree/RandomTree_%s.tre', indexn)
  sampletr=read.tree(form)
  
  obs_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1/SimulateData_New_20Missing/Ternary_alpha0%s_beta0%s/ternary_obs_0_1_tip_alpha_0%s_beta_0%s_matrix%s.csv', alpha_str, beta_str, alpha_str, beta_str,indexn)
  prob_form_0_1 =  sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/Ternary_alpha0%s_beta0%s_result/all_ternary_prob_matrix_all_0_1_out_matrix%s.csv",alpha_str,beta_str,indexn)
  
  mat_obs_form_0_1 = read.csv(obs_form_0_1)
  mat_obs_form_0_1_sub= na.omit(mat_obs_form_0_1)
  mat_prob_form_0_1 = read.csv(prob_form_0_1)
  
  #find children branches of each br
  true_near_branch = compare_near_order(length(sampletr$edge.length),length(sampletr$tip.label),sampletr)
  
  all_true_near_branch = data.frame(matrix(, nrow=0, ncol=2))
  all_match_near_branch_sub = data.frame(matrix(, nrow=0, ncol=2))
  
  #put all adjacent paired branches in a dataframe
  for (br in 1:length(true_near_branch)){
    
    if(length(true_near_branch[[br]])>0){
      for(br_sub in 1:length(true_near_branch[[br]])){
        all_true_near_branch = rbind(all_true_near_branch,c(br,(true_near_branch[[br]])[br_sub]))
      }
    }
  }
  
  all_true_near_branch_sub=na.omit(all_true_near_branch)
  colnames(all_true_near_branch_sub) = c("first_br_indexn","second_br_indexn")
  exclude_branch = setdiff(c(1:18), mat_prob_form_0_1$First_branch)
  
  
  
  
  if (length(exclude_branch) == 0 ){
    
    for (i in 1:dim(all_true_near_branch_sub)[1]){
    
    print(c(indexn,i))
    #find the inferred br of each true pair
    first_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,1],-c(1,2,3,4)]))
    second_br_indexn=which.max((mat_prob_form_0_1[all_true_near_branch_sub[i,2],-c(1,2,3,4)]))
    br_indexn=data.frame(first_br_indexn,second_br_indexn)
    
    matchresult = match_df(all_true_near_branch_sub, br_indexn)
    
    all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }
    
    }else {
    
      
      for(rm in 1:length(exclude_branch)){
      
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$first_br_indexn == (exclude_branch[rm]) ),]
        all_true_near_branch_sub<-all_true_near_branch_sub[!(all_true_near_branch_sub$second_br_indexn == (exclude_branch[rm])),]
      
      }
    
    
      for(i in 1:dim(all_true_near_branch_sub)[1]){
      
      print(c(indexn,i))
      
      
      first_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,1]),])[,-c(1,2,3,4)])
      second_br_indexn=which.max((mat_prob_form_0_1[which(mat_prob_form_0_1$First_branch == all_true_near_branch_sub[i,2]),])[,-c(1,2,3,4)])
      
      br_indexn=data.frame(first_br_indexn,second_br_indexn)
      
      matchresult = match_df(all_true_near_branch_sub, br_indexn)
      
      all_match_near_branch_sub=rbind(all_match_near_branch_sub, matchresult)
    }}
    
  
  adjacent_pair_result[indexn,]=c(dim(all_match_near_branch_sub)[1],dim(all_true_near_branch_sub)[1])
  
}


adjacent_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_Ternary_20missing/summary/ternary_adjacent_order_alpha_0%s_beta_0%s.csv', alpha_str, beta_str)
write.csv(adjacent_pair_result,file=adjacent_pair_result_form_0_1)


}




```

Finally, we summarize the location accuracy, interval accuracy, adjacent accuracy, and order accuracy as below:

```{r}

library(plyr)
library(ape)

parameter_setting = expand.grid(alpha=c(0.05,0.1,0.2,0.4),
                                beta =c(0.05,0.1,0.2,0.4),
                                missingindex=c(0,10,20),
                                genotype = c("Binary","Ternary"))
######################################################################
#interval accuracy
#columns for correct inferred pairs,true pairs,numSites,alpha,beta,missing index, genotype, Method="MO"

all_pair_result_dat= c()


for(parameterindex in 1:dim(parameter_setting)[1]){
  
  print(parameterindex)
  alpha =   parameter_setting[parameterindex,1]
  beta = parameter_setting[parameterindex,2]
  missingindex = parameter_setting[parameterindex,3]
  genotype = as.character(parameter_setting[parameterindex,4])
  genotype_lowercase = tolower(genotype)
  
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }


if(missingindex==0){
  
  individual_res = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_%s/summary/%s_interval_alpha_0%s_beta_0%s_matrix.csv",genotype,genotype_lowercase,alpha_str,beta_str)
  
}else{
  
  individual_res = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_%s_%smissing/summary/%s_interval_alpha_0%s_beta_0%s_matrix.csv",genotype,missingindex,genotype_lowercase,alpha_str,beta_str)
  
}

  all_pair_result = read.csv(individual_res)

  all_pair_result_complete = data.frame(inferred = all_pair_result[,c(4)],
                                        true = rep(1,dim(all_pair_result)[1]),
                                   numSites = rep(18,dim(all_pair_result)[1]), 
                                   alpha_para = rep(alpha,dim(all_pair_result)[1]),
                                   beta_para = rep(beta,dim(all_pair_result)[1]),
                                   missing_index = rep(missingindex,dim(all_pair_result)[1]), 
                                   genotype_para = rep(genotype,dim(all_pair_result)[1]), 
                                   Method=rep("MO",dim(all_pair_result)[1]))
  colnames(all_pair_result_complete)[1:2] = c("inferred","true")
  
  
  
  all_pair_result_dat = rbind(all_pair_result_dat,all_pair_result_complete[1:100,])


}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/accuracy/scenario1_interval_accuracy.csv')
write.csv(all_pair_result_dat,file=all_pair_result_form_0_1)





######################################################################
#location accuracy
#columns for correct inferred pairs,true pairs,numSites,alpha,beta,missing index, genotype, Method="MO"

all_pair_result_dat= c()


for(parameterindex in 1:dim(parameter_setting)[1]){
  
  print(parameterindex)
  alpha =   parameter_setting[parameterindex,1]
  beta = parameter_setting[parameterindex,2]
  missingindex = parameter_setting[parameterindex,3]
  genotype = as.character(parameter_setting[parameterindex,4])
  genotype_lowercase = tolower(genotype)
  
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }
  
  
  if(missingindex==0){
    
    individual_res = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_%s/summary/%s_location_alpha_0%s_beta_0%s.csv",genotype,genotype_lowercase,alpha_str,beta_str)
    
  }else{
    
    individual_res = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_%s_%smissing/summary/%s_location_alpha_0%s_beta_0%s.csv",genotype,missingindex,genotype_lowercase,alpha_str,beta_str)
    
  }
  
  all_pair_result = read.csv(individual_res)
  
  all_pair_result_complete = data.frame(inferred = all_pair_result[,c("cat")],
                                        true = rep(1,dim(all_pair_result)[1]),
                                   numSites = rep(18,dim(all_pair_result)[1]), 
                                   alpha_para = rep(alpha,dim(all_pair_result)[1]),
                                   beta_para = rep(beta,dim(all_pair_result)[1]),
                                   missing_index = rep(missingindex,dim(all_pair_result)[1]), 
                                   genotype_para = rep(genotype,dim(all_pair_result)[1]), 
                                   Method=rep("MO",dim(all_pair_result)[1]))
  
  
  colnames(all_pair_result_complete)[1:2] = c("inferred","true")
  
  all_pair_result_dat = rbind(all_pair_result_dat,all_pair_result_complete[1:100,])
  
  
}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/accuracy/scenario1_location_accuracy.csv')
write.csv(all_pair_result_dat,file=all_pair_result_form_0_1)


####################################################################
#for adjacent order accuracy
#columns for correct inferred pairs,true pairs,numSites,alpha,beta,missing index, genotype, Method="MO"

all_pair_result_dat= c()


for(parameterindex in 1:dim(parameter_setting)[1]){
  
  print(parameterindex)
  alpha =   parameter_setting[parameterindex,1]
  beta = parameter_setting[parameterindex,2]
  missingindex = parameter_setting[parameterindex,3]
  genotype = as.character(parameter_setting[parameterindex,4])
  genotype_lowercase = tolower(genotype)
  
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }


if(missingindex==0){
  
  individual_res = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_%s/summary/%s_adjacent_order_alpha_0%s_beta_0%s.csv",genotype,genotype_lowercase,alpha_str,beta_str)
  
}else{
  
  individual_res = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_%s_%smissing/summary/%s_adjacent_order_alpha_0%s_beta_0%s.csv",genotype,missingindex,genotype_lowercase,alpha_str,beta_str)
  
}

  all_pair_result = read.csv(individual_res)

  all_pair_result_complete = cbind(all_pair_result[,c(2,3)],
                                   numSites = rep(18,dim(all_pair_result)[1]), 
                                   alpha_para = rep(alpha,dim(all_pair_result)[1]),
                                   beta_para = rep(beta,dim(all_pair_result)[1]),
                                   missing_index = rep(missingindex,dim(all_pair_result)[1]), 
                                   genotype_para = rep(genotype,dim(all_pair_result)[1]), 
                                   Method=rep("MO",dim(all_pair_result)[1]))
  colnames(all_pair_result_complete)[1:2] = c("inferred","true")
  
  all_pair_result_dat = rbind(all_pair_result_dat,all_pair_result_complete[1:100,])


}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/accuracy/scenario1_adjacent_order_accuracy.csv')
write.csv(all_pair_result_dat,file=all_pair_result_form_0_1)




#for all order accuracy
#columns for correct inferred pairs,true pairs,numSites,alpha,beta,missing index, genotype, Method="MO"

all_pair_result_dat= c()


for(parameterindex in 1:dim(parameter_setting)[1]){
  
  print(parameterindex)
  alpha  =  parameter_setting[parameterindex,1]
  beta = parameter_setting[parameterindex,2]
  missingindex = parameter_setting[parameterindex,3]
  genotype = as.character(parameter_setting[parameterindex,4])
  genotype_lowercase = tolower(genotype)
  
  if (alpha < 0.1)
  {
    alpha_str = sprintf('0%s', alpha*100)
  } else
  {
    alpha_str = sprintf('%s', alpha*10)
  }
  
  if (beta < 0.1)
  {
    beta_str = sprintf('0%s', beta*100)
  } else
  {
    beta_str = sprintf('%s', beta*10)
  }


if(missingindex==0){
  
  individual_res = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_%s/summary/%s_all_order_alpha_0%s_beta_0%s.csv",genotype,genotype_lowercase,alpha_str,beta_str)
  
}else{
  
  individual_res = sprintf("./Figures3_4_Scenarios1_2/Scenario1_result_rmd/MO_%s_%smissing/summary/%s_all_order_alpha_0%s_beta_0%s.csv",genotype,missingindex,genotype_lowercase,alpha_str,beta_str)
  
}

  all_pair_result = read.csv(individual_res)

  all_pair_result_complete = cbind(all_pair_result[,c(2,3)],
                                   numSites = rep(18,dim(all_pair_result)[1]), 
                                   alpha_para = rep(alpha,dim(all_pair_result)[1]),
                                   beta_para = rep(beta,dim(all_pair_result)[1]),
                                   missing_index = rep(missingindex,dim(all_pair_result)[1]), 
                                   genotype_para = rep(genotype,dim(all_pair_result)[1]), 
                                   Method=rep("MO",dim(all_pair_result)[1]))
  colnames(all_pair_result_complete)[1:2] = c("inferred","true")
  
  all_pair_result_dat = rbind(all_pair_result_dat,all_pair_result_complete[1:100,])


}

all_pair_result_form_0_1 = sprintf('./Figures3_4_Scenarios1_2/Scenario1_result_rmd/accuracy/scenario1_all_order_accuracy.csv')
write.csv(all_pair_result_dat,file=all_pair_result_form_0_1)


```
